# MFT 大小估算和内存映射可行性分析

## MFT 大小计算

```
MFT 总大小 = MFT记录数 × 每条记录大小
每条记录通常 = 1024 字节 (1KB)
```

### 典型场景：

| 卷大小 | 估计文件数 | MFT记录数 | MFT大小 |
|--------|-----------|-----------|---------|
| 100 GB | 50万 | 50万 | 512 MB |
| 500 GB | 200万 | 200万 | 2 GB |
| 1 TB | 500万 | 500万 | 5 GB |
| 2 TB | 1000万 | 1000万 | 10 GB |

**注意**: MFT通常占卷大小的0.5%-2%

---

## 内存映射原理

### 关键概念：
```
内存映射 ≠ 全部加载到物理内存(RAM)
```

**内存映射的实际行为：**
1. **虚拟地址空间** - 创建地址映射，不占用物理内存
2. **按需分页** - 操作系统按需加载页面（4KB为单位）
3. **自动缓存** - OS自动管理页面缓存
4. **物理内存占用** = 实际访问的页面数 × 4KB

### 示例：
```cpp
// 映射5GB的MFT
MapViewOfFile(..., 5GB);  // 只占用虚拟地址空间，物理内存≈0

// 顺序访问时
for (每个记录) {
    访问MFT记录;  // OS自动加载需要的4KB页面到RAM
}
// 实际物理内存占用：取决于OS页面缓存策略，通常几百MB
```

---

## 风险分析

### ✅ 安全场景（不会溢出）：

#### 1. 64位系统 + 中等卷 (< 2TB)
- **虚拟地址空间**: 128TB（Windows 实际可用：8TB+）
- **MFT大小**: < 10GB
- **风险**: **无**，虚拟地址空间充足

#### 2. 32位系统 + 小卷 (< 500GB)
- **虚拟地址空间**: 2GB（用户空间）
- **MFT大小**: < 2GB
- **风险**: **低**，但接近上限，建议分段映射

---

### ⚠️ 高风险场景：

#### 1. 32位系统 + 大卷 (> 1TB)
- **虚拟地址空间**: 2GB
- **MFT大小**: 可能 5GB+
- **风险**: **无法映射**，会失败
- **解决方案**: **必须使用分段映射**

#### 2. 大规模卷 (> 5TB)
- **MFT大小**: 可能 > 25GB
- **风险**: 即使64位系统，一次性映射也可能影响性能
- **解决方案**: **分段映射**

---

## 物理内存(RAM)占用

### 误区：
```
❌ 错误理解：映射5GB MFT = 占用5GB RAM
✅ 正确理解：映射5GB MFT，顺序访问时RAM占用取决于OS缓存策略
```

### 实际RAM占用：

#### 顺序扫描（最优）：
```
物理内存 ≈ 预读缓存大小 (通常 64MB - 256MB)
```

#### 随机访问（最差）：
```
物理内存 ≈ min(实际访问的页面数 × 4KB, 可用RAM)
```

### 示例测试：
```cpp
// 映射5GB MFT，顺序访问
LPVOID pMFT = MapViewOfFile(..., 5GB);

// 访问前: RAM占用 ≈ 0MB
// 顺序读取所有记录
for (i = 0; i < 记录数; i++) {
    BYTE* record = (BYTE*)pMFT + i * 1024;
    ProcessRecord(record);
}
// 访问中: RAM占用 ≈ 100-300MB（OS缓存）
// 访问后: UnmapViewOfFile()，RAM立即释放
```

---

## 推荐方案

### 方案1：小卷直接映射 (< 2GB MFT)
```cpp
// 适用于：MFT < 2GB
ULONGLONG mftSize = totalRecords * bytesPerFileRecord;
if (mftSize < 2ULL * 1024 * 1024 * 1024) {  // < 2GB
    // 直接映射整个MFT
    MapViewOfFile(..., 0, 0, mftSize);
}
```

**优点**: 实现简单，性能最优
**缺点**: 不适用于大卷

---

### 方案2：分段映射（推荐，适用所有场景）
```cpp
const ULONGLONG SEGMENT_SIZE = 256ULL * 1024 * 1024;  // 256MB一段

for (ULONGLONG offset = 0; offset < mftSize; offset += SEGMENT_SIZE) {
    ULONGLONG mapSize = min(SEGMENT_SIZE, mftSize - offset);

    LPVOID pSegment = MapViewOfFile(
        hMapping,
        FILE_MAP_READ,
        (offset >> 32),           // 高32位
        (offset & 0xFFFFFFFF),    // 低32位
        mapSize
    );

    // 处理这一段
    ProcessSegment(pSegment, mapSize);

    // 释放
    UnmapViewOfFile(pSegment);
}
```

**优点**:
- ✅ 支持任意大小的MFT
- ✅ 虚拟内存占用可控（256MB）
- ✅ 物理内存占用小
- ✅ 32位/64位系统通用

**缺点**:
- 需要处理段边界

---

### 方案3：自适应映射（最优）
```cpp
// 根据系统架构和MFT大小自动选择
ULONGLONG mftSize = GetMFTSize();
bool is64Bit = (sizeof(void*) == 8);

if (is64Bit && mftSize < 4ULL * 1024 * 1024 * 1024) {
    // 64位系统，MFT < 4GB，直接映射
    DirectMapping();
} else {
    // 其他情况，分段映射
    SegmentedMapping();
}
```

---

## 性能对比

| 方法 | I/O次数 | 内存占用(虚拟) | 内存占用(物理) | 复杂度 |
|-----|---------|---------------|---------------|--------|
| 逐条ReadFile | N (每条1次) | 小 | 小 | 简单 |
| 批量ReadFile | N/256 | 中 | 中 | 中等 |
| 直接内存映射 | 1 (初始化) | MFT大小 | 缓存大小 | 简单 |
| 分段内存映射 | 段数 | 256MB | 缓存大小 | 中等 |

---

## 结论

### ✅ 内存映射是可行的，不会导致物理内存溢出

**推荐实现顺序**：
1. **优先使用分段映射** - 安全、通用、性能好
2. 对小卷可优化为直接映射
3. 添加自适应逻辑

### 风险控制：
- ✅ 虚拟内存溢出风险：**低**（使用分段映射）
- ✅ 物理内存溢出风险：**无**（按需分页）
- ✅ 32位系统兼容性：**好**（分段映射）
